"""
Módulo de configuração do banco de dados Oracle
Contém configurações e parâmetros de conexão
"""

import os

def obter_config_banco():
    """
    Retorna as configurações de conexão com o banco Oracle
    
    Returns:
        dict: Dicionário com configurações de conexão
    """
    # Configurações padrão para desenvolvimento
    # Em produção, use variáveis de ambiente para maior segurança
    config = {
        'host': os.getenv('ORACLE_HOST', 'localhost'),
        'port': int(os.getenv('ORACLE_PORT', 1521)),
        'service_name': os.getenv('ORACLE_SERVICE', 'ORCL'),  # Oracle Express Edition
        'user': os.getenv('ORACLE_USER', 'root'),
        'password': os.getenv('ORACLE_PASSWORD', 'root'),
        'encoding': 'UTF-8'
    }
    
    return config

def obter_dsn():
    """
    Constrói o DSN (Data Source Name) para conexão Oracle
    
    Returns:
        str: String de conexão DSN
    """
    config = obter_config_banco()
    
    # Formato: host:port/service_name
    dsn = f"{config['host']}:{config['port']}/{config['service_name']}"
    
    return dsn

def obter_string_conexao():
    """
    Retorna string de conexão completa para Oracle
    
    Returns:
        dict: Parâmetros de conexão
    """
    config = obter_config_banco()
    
    return {
        'user': config['user'],
        'password': config['password'],
        'dsn': obter_dsn(),
        'encoding': config['encoding']
    }

# Configurações de timeout e pool de conexões
CONFIG_AVANCADA = {
    'timeout': 30,  # Timeout em segundos
    'retry_count': 3,  # Número de tentativas de reconexão
    'pool_min': 1,  # Mínimo de conexões no pool
    'pool_max': 5,  # Máximo de conexões no pool
    'pool_increment': 1  # Incremento do pool
}

# SQL para criação das tabelas
SQL_CREATE_TABLES = {
    'propriedades': """
        CREATE TABLE propriedades (
            id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            nome VARCHAR2(100) NOT NULL UNIQUE,
            area_total NUMBER(10,2) NOT NULL CHECK (area_total > 0),
            localizacao VARCHAR2(200) NOT NULL,
            tipo_solo VARCHAR2(50) NOT NULL,
            data_cadastro DATE DEFAULT SYSDATE
        )
    """,
    
    'colheitas': """
        CREATE TABLE colheitas (
            id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            propriedade_id NUMBER NOT NULL,
            data_colheita DATE NOT NULL,
            area_colhida NUMBER(10,2) NOT NULL CHECK (area_colhida > 0),
            quantidade_colhida NUMBER(10,2) NOT NULL CHECK (quantidade_colhida > 0),
            tipo_colheita VARCHAR2(20) NOT NULL CHECK (tipo_colheita IN ('manual', 'mecanica')),
            produtividade NUMBER(10,2),
            percentual_perda NUMBER(5,2),
            data_registro DATE DEFAULT SYSDATE,
            CONSTRAINT fk_colheita_propriedade 
                FOREIGN KEY (propriedade_id) REFERENCES propriedades(id) ON DELETE CASCADE
        )
    """,
    
    'sequences': [
        "CREATE SEQUENCE seq_propriedades START WITH 1 INCREMENT BY 1",
        "CREATE SEQUENCE seq_colheitas START WITH 1 INCREMENT BY 1"
    ]
}

# SQL para inserção de dados
SQL_INSERT = {
    'propriedade': """
        INSERT INTO propriedades (nome, area_total, localizacao, tipo_solo)
        VALUES (:nome, :area_total, :localizacao, :tipo_solo)
    """,
    
    'colheita': """
        INSERT INTO colheitas (propriedade_id, data_colheita, area_colhida, 
                              quantidade_colhida, tipo_colheita, produtividade, percentual_perda)
        VALUES (:propriedade_id, TO_DATE(:data_colheita, 'DD/MM/YYYY'), :area_colhida,
                :quantidade_colhida, :tipo_colheita, :produtividade, :percentual_perda)
    """
}

# SQL para consultas
SQL_SELECT = {
    'todas_propriedades': """
        SELECT id, nome, area_total, localizacao, tipo_solo, data_cadastro
        FROM propriedades
        ORDER BY nome
    """,
    
    'propriedade_por_id': """
        SELECT id, nome, area_total, localizacao, tipo_solo, data_cadastro
        FROM propriedades
        WHERE id = :id
    """,
    
    'propriedade_por_nome': """
        SELECT id, nome, area_total, localizacao, tipo_solo, data_cadastro
        FROM propriedades
        WHERE UPPER(nome) = UPPER(:nome)
    """,
    
    'colheitas_por_propriedade': """
        SELECT id, propriedade_id, data_colheita, area_colhida, quantidade_colhida,
               tipo_colheita, produtividade, percentual_perda, data_registro
        FROM colheitas
        WHERE propriedade_id = :propriedade_id
        ORDER BY data_colheita DESC
    """,
    
    'todas_colheitas': """
        SELECT c.id, c.propriedade_id, p.nome as propriedade_nome,
               c.data_colheita, c.area_colhida, c.quantidade_colhida,
               c.tipo_colheita, c.produtividade, c.percentual_perda, c.data_registro
        FROM colheitas c
        JOIN propriedades p ON c.propriedade_id = p.id
        ORDER BY c.data_colheita DESC
    """,
    
    'estatisticas_gerais': """
        SELECT 
            COUNT(DISTINCT p.id) as total_propriedades,
            COUNT(c.id) as total_colheitas,
            SUM(c.area_colhida) as area_total_colhida,
            SUM(c.quantidade_colhida) as quantidade_total_colhida,
            AVG(c.produtividade) as produtividade_media,
            AVG(c.percentual_perda) as perda_media
        FROM propriedades p
        LEFT JOIN colheitas c ON p.id = c.propriedade_id
    """
}

def exibir_configuracao():
    """
    Exibe as configurações atuais do banco (sem mostrar senha)
    """
    config = obter_config_banco()
    
    print("=== CONFIGURAÇÃO DO BANCO ORACLE ===")
    print(f"Host: {config['host']}")
    print(f"Porta: {config['port']}")
    print(f"Service Name: {config['service_name']}")
    print(f"Usuário: {config['user']}")
    print(f"DSN: {obter_dsn()}")
    print("=====================================")

def validar_configuracao():
    """
    Valida se as configurações estão corretas
    
    Returns:
        tuple: (bool, str) - (é_válido, mensagem)
    """
    try:
        config = obter_config_banco()
        
        # Verificar campos obrigatórios
        campos_obrigatorios = ['host', 'port', 'service_name', 'user', 'password']
        for campo in campos_obrigatorios:
            if not config.get(campo):
                return False, f"Campo obrigatório não configurado: {campo}"
        
        # Verificar se porta é numérica
        if not isinstance(config['port'], int) or config['port'] <= 0:
            return False, "Porta deve ser um número positivo"
        
        return True, "Configuração válida"
        
    except Exception as e:
        return False, f"Erro na configuração: {e}"